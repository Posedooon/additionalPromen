# ここで困った!orなるほど！となったことをメモしていく

# 仕組み部分

- @WicketHomePage は、Wicket-Spring-Bootが表示する最初のページに設定する  
- @MountPath("Home") は、HomePageクラスとそのHTMLを http://.../Home というURLでアクセスできるよう、URLのファイルパス部を設定する  
- Wicketが提供する WebPage クラスを継承することで、同じ名前のHTMLファイルを書き換える能力をもつ  
- JavaプログラムのLabel部分はHTMLページで設定したwicketidと反映させたいものを対にして構成される  
- BookmarkablePageLinkコンポーネントを使うと、任意のタグを任意のページへのリンクに書き換えられる  
- ____ラベルやリンクを設定したら必ずaddする！！！！____

- ブラウザから入力・送信された値は、UserMakerPage の Form の onSubmit の中で取得される  

- UserMakerPage の Form は、 IUserService のregisterUser機能に、取得した入力値（記録してほしいユーザIdとパスワード）を依頼する  
- IUserService の registerUser 機能は、渡された入力値を IAuthUserRepository の insert 機能に依頼する  
- IAuthUserRepository の insert 機能 は、H2DBにデータの登録を依頼し、呼び出し元に記録行数を返す  
- IUserService の registerUser 機能は、IAuthUserRepository から返された記録行数を標準出力に表示する  
- UserMakerPage の Form は、IUserService の registerUser機能の終了後、UserMakerCompPageを作ってブラウザに返し、ブラウザに UserMakerCompPage が表示される  
# 匿名クラス（無名クラス）という概念について
- __新しくクラスを作成せずに抽象クラスやインタフェースをそのままインスタンス化させるような動作を行うことができる__  
- __クラス名が無い。ほとんどの場合、あるメソッドの中で宣言され、その中でしか使われない (1回かぎり)__
~~~
new 親クラスまたはインターフェイス名() {
    // 匿名クラスの内容 (フィールドやメソッドの定義)
};
~~~

## ユーザー認証はどのように作るか

ユーザ認証を作る方法は様々だが、Webシステムで最も基本的な方法は、

1. 認証済でなければ利用できないページを用意する
1. ある人物しか使えない情報（例：パスワード）がWebシステムに送られる
1. 送られた情報とWebシステム側の情報を照合する
1. 照合結果がOKであれば、ブラウザごとに情報を一時保存できる領域（例：HTTPセッションなど）に認証結果や付属情報（たとえば、システムの利用権限）となる情報を格納する
1. 照合結果がNGであれば、認証を促す（認証ページに移動させるなど）

という手順で作成できる。ここではこれを順を追って説明する。

<!--認証後時間が長く経った場合、同じブラウザを違う人間が使うことも考えられる。従って一定時間が経過したら、もう一度(OK/NG)を確認するか、もう一度（あるブラウザからWebシステムに送られてきた情報、外に出てくることを促す。-->

----
※今回はWicketに備わっている標準の認証フレームワーク Wicket-Auth-Roles を使う  
MySession.javaクラスを作る。重要なのは3つのメソッド
- **sign メソッド**<br>別の場所で行われた認証（照合）が成功したら、照合できたユーザ名を一時記録する。セッションはブラウザごとに用意されるので、ブラウザごとの利用者のユーザ名となる。
- **getRoles メソッド**<br>認証したユーザの役割を返り値にする。<strong>Wicketはこの値を使って、ページを表示してよいかダメかを判定する</strong>。この例では全員が `USER`（一般ユーザ） という役割になると一律で設定しているが、ユーザごとに管理者や他の役割（学生、教育、ゲスト...）を区別するようにもできる。
- **get メソッド**<br>クラスメソッド（staticなメソッド）なので、インスタンス化（new）せずに利用できる。Wicketでセッション情報を変更したり取り出したりするときは、必ずこのメソッド経由で行う（後述）。


Applicationクラスの返り値を変えて、 getWebSession メソッドをオーバーライドする。  
先ほど作成した MySession クラスを返り値とすれば、このクラスの getRoles メソッドを使って、ページの表示の可・不可を判断させることができる

<確認部分>
- Wicketは、 _@AuthorizeInstantiation_ に設定されている _Roles.USER_ と、 _MySession_ クラスの _getRoles_ メソッドの戻り値で、ページ表示の可・不可を判断する。

- MySession クラスの _getRoles_ メソッドは、ユーザ認証済みの時に _new Roles(Roles.USER)_ を戻す。_new Roles()_ の中身が _@AuthorizeInstantiation_ の値と一致しているので、ページを表示する。

- 一方で、 _MySession_ クラスの _getRoles_ メソッドは、ユーザが未認証の時に _new Roles()_ を戻す。_new Roles()_ の中身が _@AuthorizeInstantiation_ の値と一致していないので、ページを表示しない

## （重要） Wicketでのセッションの利用方法

Wicket でセッション用のインスタンスを使うときは、

- 必ず `MySession.get()` で呼び出す
- `MySession.get()` を変数に入れない

というルールを守って利用する。これは[ユーザ追加フォームを作成する 03](https://github.com/gishi-yama/wicket_spring-boot_practice/blob/master/doc/C01/03.md#%E9%87%8D%E8%A6%81%E3%81%AA%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88)で説明した「**ステートフル**」が関係している。

Wicketでは、**ステートフルなページの情報（つまり、変数・モデル・コンポーネントの状態）もブラウザごとのセッションで管理**している。もしページの中でセッションを変数にいれてしまうと、変数に入ったセッションの情報を同じセッションが管理する、というデータの循環が発生してしまう。

これを防ぐために、セッションを利用する場合は必ず  `MySession.get().･･･` とメモリ上のセッションインスタンスを直接指定するコードにして、メソッドを実行する。


# コピペ注意報
SignedPage.javaにて発生。ListViewというコンポーネントがWicked以外にも存在(javax.swing.text.html.ListView)し、 
そちらが読み込まれることでエラーが発生する事態が発生した。手打ちでWickedのコンポーネントを指定すれば解決するのでメモしておく。

# データベースに書き込めないんだが？
"read only mode"みたいなエラー出てなんかできない→IDE上でデータベース再読み込みしたら解決した  

# Listで表示させようとしてた時に「text_bodyが見つかりません」というエラーが起きたんだが？
どうやって解決したのか忘れた。気合で何とかした気がする  

# 認証済みの人だけ見せるのどうするんだっけ
認証済みであれば表示できるようにするページに、@AuthorizeInstantiation アノテーションを設定するといい。
# 適宜更新！